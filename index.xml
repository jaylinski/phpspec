<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quick Start on phpspec</title><link>https://jaylinski.github.io/phpspec/</link><description>Recent content in Quick Start on phpspec</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://jaylinski.github.io/phpspec/index.xml" rel="self" type="application/rss+xml"/><item><title>Configuration</title><link>https://jaylinski.github.io/phpspec/cookbook/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/cookbook/configuration/</guid><description>Some things in phpspec can be configured in a phpspec.yml, .phpspec.yml, or phpspec.yml.dist file in the root of your project (the directory where you run the phpspec command).
You can use a different config file name and path with the --config option:
$ bin/phpspec run --config path/to/different-phpspec.yml You can use the .yaml extension in place of .yml if preferred.
You can also specify default values for config variables across all repositories by creating the file .</description></item><item><title>Introduction</title><link>https://jaylinski.github.io/phpspec/manual/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/manual/introduction/</guid><description>SpecBDD with phpspec phpspec is a tool which can help you write clean and working PHP code using behaviour driven development or BDD. BDD is a technique derived from test-first development.
BDD is a technique used at story level and spec level. phpspec is a tool for use at the spec level or SpecBDD. The technique is to first use a tool like phpspec to describe the behaviour of an object you are about to write.</description></item><item><title>Installation</title><link>https://jaylinski.github.io/phpspec/manual/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/manual/installation/</guid><description>phpspec is a PHP library that you&amp;rsquo;ll have in your project development environment. Before you begin, ensure that you have the correct PHP version installed.
phpspec PHP 3.x ^5.6 || ^7.0 4.x ^7.0, &amp;lt;7.3 5.x ^7.1, &amp;lt;7.4 6.x ^7.2, &amp;lt;7.5 7.x ^7.3 || 8.0.* Installation process: You can install phpspec with all its dependencies through Composer.</description></item><item><title>Running phpspec</title><link>https://jaylinski.github.io/phpspec/cookbook/console/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/cookbook/console/</guid><description>The phpspec console command uses Symfony&amp;rsquo;s console component. This means that it inherits the default Symfony console command and options.
phpspec has an additional global option to let you specify a config file other than phpspec.yml, .phpspec.yml, or phpspec.yml.dist:
$ bin/phpspec run --config path/to/different-phpspec.yml or:
$ bin/phpspec run -c path/to/different-phpspec.yml Read more about this in the Configuration Cookbook.
Also of note is that using the --no-interaction option means that no code generation will be done.</description></item><item><title>Getting Started</title><link>https://jaylinski.github.io/phpspec/manual/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/manual/getting-started/</guid><description>Say you are building a tool that converts Markdown into HTML. Well, that&amp;rsquo;s a large task. But you can work on simple things first and a design will emerge that will reach all the necessary features.
What is the simplest thing you could add? It should convert a string line into a paragraph with HTML markup, i.e. &amp;ldquo;Hi, there&amp;rdquo; would become &amp;quot;&amp;lt;p&amp;gt;Hi, there&amp;lt;/p&amp;gt;&amp;quot;.
So you can start by doing this. Well, not the boring bits.</description></item><item><title>Object Construction</title><link>https://jaylinski.github.io/phpspec/cookbook/construction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/cookbook/construction/</guid><description>In phpspec specs the object you are describing is not a separate variable but is $this. So instead of writing something like:
&amp;lt;?php namespace spec; use PhpSpec\ObjectBehavior; class MarkdownSpec extends ObjectBehavior { function it_converts_plain_text_to_html_paragraphs() { $markdown = new Markdown(); $markdown-&amp;gt;toHtml(&amp;#34;Hi, there&amp;#34;)-&amp;gt;shouldReturn(&amp;#34;&amp;lt;p&amp;gt;Hi, there&amp;lt;/p&amp;gt;&amp;#34;); } } as you might with other tools, you write:
&amp;lt;?php namespace spec; use PhpSpec\ObjectBehavior; class MarkdownSpec extends ObjectBehavior { function it_converts_plain_text_to_html_paragraphs() { $this-&amp;gt;toHtml(&amp;#34;Hi, there&amp;#34;)-&amp;gt;shouldReturn(&amp;#34;&amp;lt;p&amp;gt;Hi, there&amp;lt;/p&amp;gt;&amp;#34;); } } On consequence this means that you do not construct the object you are describing in the examples.</description></item><item><title>Matchers</title><link>https://jaylinski.github.io/phpspec/cookbook/matchers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/cookbook/matchers/</guid><description>You use matchers in phpspec to describe how an object should behave. They are like assertions in xUnit but with a focus on specifying behaviour instead of verifying output. You use the matchers prefixed by should or shouldNot as appropriate.
phpspec has 14 built-in matchers, described in more detail here. Many of these matchers have aliases which you can use to make your specifications easy to read.
Custom matchers classes can be registered in configuration.</description></item><item><title>Prophet Objects</title><link>https://jaylinski.github.io/phpspec/manual/prophet-objects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/manual/prophet-objects/</guid><description>Stubs You also need your Markdown parser to be able to format text fetched from an external source such as a file. You decide to create an interface so that you can have different implementations for different types of source.
&amp;lt;?php namespace Markdown; interface Reader { public function getMarkdown(); } You want to describe a method which has an instance of a Reader as an argument. It will call Markdown\Reader::getMarkdown() to get the markdown to format.</description></item><item><title>Let and Let Go</title><link>https://jaylinski.github.io/phpspec/manual/let-and-letgo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/manual/let-and-letgo/</guid><description>If you need to pass the object into the constructor instead of a method then you can do it like this:
&amp;lt;?php namespace spec; use PhpSpec\ObjectBehavior; use Markdown\Writer; class MarkdownSpec extends ObjectBehavior { function it_outputs_converted_text(Writer $writer) { $this-&amp;gt;beConstructedWith($writer); $writer-&amp;gt;writeText(&amp;#34;&amp;lt;p&amp;gt;Hi, there&amp;lt;/p&amp;gt;&amp;#34;)-&amp;gt;shouldBeCalled(); $this-&amp;gt;outputHtml(&amp;#34;Hi, there&amp;#34;); } } If you have many examples then writing this in each example will get tiresome. You can instead move this to a let method. The let method gets run before each example so each time the parser gets constructed with a fresh mock object.</description></item><item><title>Templates</title><link>https://jaylinski.github.io/phpspec/cookbook/templates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/cookbook/templates/</guid><description>phpspec can generate code snippets that will save you time when specifying classes. The default templates will be suitable for many use cases.
However in some cases, it&amp;rsquo;ll be useful to customize those templates by providing ones that suit your project requirements. For example, you may need to add licence information in a docblock to every class file. Instead of doing this manually you can modify the template so it is already in the generated file.</description></item><item><title>Upgrading to phpspec 7</title><link>https://jaylinski.github.io/phpspec/manual/upgrading-to-phpspec-7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/manual/upgrading-to-phpspec-7/</guid><description>Here is a guide to upgrading a test suite or an extension, based on BC-breaking changes made in phpspec 7:
https://github.com/phpspec/phpspec/blob/main/CHANGES-v7.md</description></item><item><title>Extensions</title><link>https://jaylinski.github.io/phpspec/cookbook/extensions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/cookbook/extensions/</guid><description>Extensions can add functionality to phpspec, such as, integration with a particular framework. See below for some example extensions.
Installation Individual extensions will have their own documentation that you can follow. Usually you can install an extension by adding it to your composer.json file and updating your vendors.
Configuration You will need to tell phpspec that you want to use the extension. You can do this by adding it to the config file:</description></item><item><title>Upgrading to phpspec 6</title><link>https://jaylinski.github.io/phpspec/manual/upgrading-to-phpspec-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/manual/upgrading-to-phpspec-6/</guid><description>Here is a guide to upgrading a test suite or an extension, based on BC-breaking changes made in phpspec 6:
https://github.com/phpspec/phpspec/blob/master/CHANGES-v6.md</description></item><item><title>Upgrading to phpspec 5</title><link>https://jaylinski.github.io/phpspec/manual/upgrading-to-phpspec-5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/manual/upgrading-to-phpspec-5/</guid><description>Here is a guide to upgrading a test suite or an extension, based on BC-breaking changes made in phpspec 5:
https://github.com/phpspec/phpspec/blob/master/CHANGES-v5.md</description></item><item><title>Working with Wrapped Objects</title><link>https://jaylinski.github.io/phpspec/cookbook/wrapped-objects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/cookbook/wrapped-objects/</guid><description>phpspec wraps some of the objects used in specs. For example $this is the object you are describing wrapped in a phpspec object. This is how you can call methods on $this and then call matchers on the returned values.
Most of the time this is not something you need to worry about but sometimes it can be an issue.
If you ever need to get the actual object then you can by calling $this-&amp;gt;getWrappedObject().</description></item><item><title>Upgrading to phpspec 4</title><link>https://jaylinski.github.io/phpspec/manual/upgrading-to-phpspec-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/manual/upgrading-to-phpspec-4/</guid><description>Here is a guide to upgrading a test suite or an extension, based on BC-breaking changes made in phpspec 4.
Upgrading for Users If you are using 3rd party phpspec extensions, you may have to increase the version numbers for those as well.
As PHP 5 is no longer supported language versions, you will need to upgrade to PHP 7 to use phpspec 4.
Most methods in PhpSpec now have static type hints and return types, this will affect you when you are overriding behaviour from a parent class or implementing an interface.</description></item><item><title>Upgrading to phpspec 3</title><link>https://jaylinski.github.io/phpspec/manual/upgrading-to-phpspec-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jaylinski.github.io/phpspec/manual/upgrading-to-phpspec-3/</guid><description>Here is a guide to upgrading a test suite or an extension, based on BC-breaking changes made in phpspec 3.
Upgrading for Users If you are using 3rd party phpspec extensions, you may have to increase the version numbers for those as well.
As PHP 5.5 and below are no longer supported language versions, you will need to upgrade to PHP 5.6 or 7.0+ to use phpspec 3.
Where you have used @param annotations for spec examples, to indicate the required type for a collaborator, you will need to remove these and use explicit typehinting in the method signature instead.</description></item></channel></rss>